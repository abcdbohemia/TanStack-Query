//Change the base URL to point to your local proxy prefix
const API_BASE_URL = import.meta.env.PROD ? 'https://fakestoreapi.com' /*Direct URL for production*/ : '/api'; //Use proxy for development
//this baseURL is the localhost address and port where vite dev server is running
//In development my frontend makes a request to my local Vite Dev Server and thats where the '/api' is sent
//In production my frontend makes a request to  my hosting platform's server such as netlify and thats where the '/api' is sent
//This will be proxied to https://fakestoreapi.com

// Vite exposes environment variables through import.meta.env.
// The execution mode, determined by the command (`vite dev` for development/localhost,
// or `vite build` for production/Netlify), directly sets the boolean value
// for `import.meta.env.PROD`, influencing these metadata flags.

//Helper function to handle fetch responses and errors
const handleResponse = async (response) => {
    if (!response.ok) {
        const errorData = await response.json().catch(() =>
        ({ message: 'Unknown error' })); // () around {} there for Implicit Return of Object Literal it resolve a syntactic ambiguity for arrow functions that use an implicit return
        // The .catch block message ({ message: 'Unknown error' }) is a fallback message 
        // that your client-side code generates. It's used only when the response.json() 
        // method fails to parse the server's response body as valid JSON 
        throw new Error(errorData.message || `HTTP error! Status: ${response.status}`);   
    }
    return response.json();
};

//Function to fetch all products with optional filters
export const fetchProducts = async (filters = {}) => {
    const params = new URLSearchParams();
    // new URLSearchParams() creates a new, empty object using a built-in browser API. 
    // because your JavaScript code (whether it's a React/Vite application or plain JavaScript) 
    // runs inside that web browser, it has direct access to all of these built-in browser APIs, including URLSearchParams.
    // This object makes it much easier and ensures correct formatting 
    // when you want to build or add ?key=value parameters to a URL's query string.
    if (filters.limit) params.append('limit', filters.limit); //checks for limit property on filter object, if present, appends a 'limit' parameter and its value (filters.limit) to the URLSearchParams object
    if (filters.sort) params.append('sort', filters.sort);

    const url = filters.category? `${API_BASE_URL}/products/category/${filters.category}` 
    : `${API_BASE_URL}/products`;
    // filters.category is a single value that fits directly into that part of the URL, 
    // and template literals handle its basic string conversion automatically. No need for.toString() here.

    //Conditionally add the query string
    const fullUrl= params.toString() ? `${url}?${params.toString()}` :url;
    // params.toString() is a specific method of the URLSearchParams object
    // transforms an object-like collection of parameters into a single, 
    // ready-to-use string for the query part of a URL.

    const response = await fetch(fullUrl);
    return handleResponse(response);
};

//So the URLSearchParams is what goes a the end of the url?
// No quite, a string representation of the parameters that the URLSearchParams 
// object has collected, generated by its .toString() method does


//Function to fetch a single product by ID used by ProductDetail
export const fetchProductById = async (id) => {
    const response = await fetch(`${API_BASE_URL}/products/${id}`);
    return handleResponse(response);
}

//Function to fatch all product categories  (so could use this in a category selector dropdown menu for example)
export const fetchCategories = async () => {
    const response = await fetch(`${API_BASE_URL}/products/categories`); //returns all categories
    return handleResponse(response);
};

// createProduct: Its sole purpose is to add new products to the store's 
// overall catalog/inventory (typically done by an admin). 
// The second argument of fetch is the Options Object. This is an object that configures the details of the HTTP request.
export const createProduct = async (newProduct) => {
    const response = await fetch(`${API_BASE_URL}/products`, {
        method: 'POST',
        headers: {
            'Content-Type': 'application/json',
// when you set 'Content-Type': 'application/json', you are referring to the format of the data 
// after it has been stringified and placed into the request body
        }, 
        body: JSON.stringify(newProduct),
    });
    return handleResponse(response);
    };


// This function would almost exclusively be found and called within an admin panel or a product 
// management interface, where a store administrator or content manager can view, edit, and save 
// changes to products already listed for sale.
export const updateProduct = async (id, updatedProduct) => {
    const response = await fetch(`${API_BASE_URL}/products/${id}`, {
        method: 'POST',
        headers: {
            'Content-Type': 'application/json',
        }, 
        body: JSON.stringify(updatedProduct),
    });
    return handleResponse(response);
};

// use deleteProduct within an admin panel or a product management interface. An administrator would 
// use this function to remove items that are no longer being sold, are out of stock indefinitely, 
// or were added by mistake.
export const deleteProduct = async (id) => {
    const response = await fetch(`${API_BASE_URL}/products/${id}`, {
        method: 'DELETE', 
    });
    return handleResponse(response);
}